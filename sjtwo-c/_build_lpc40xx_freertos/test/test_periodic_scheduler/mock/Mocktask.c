/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mocktask.h"

static const char* CMockString_pcName = "pcName";
static const char* CMockString_pvParameters = "pvParameters";
static const char* CMockString_pxCreatedTask = "pxCreatedTask";
static const char* CMockString_pxPreviousWakeTime = "pxPreviousWakeTime";
static const char* CMockString_pxTaskCode = "pxTaskCode";
static const char* CMockString_taskENTER_CRITICAL = "taskENTER_CRITICAL";
static const char* CMockString_taskEXIT_CRITICAL = "taskEXIT_CRITICAL";
static const char* CMockString_usStackDepth = "usStackDepth";
static const char* CMockString_uxPriority = "uxPriority";
static const char* CMockString_vTaskDelay = "vTaskDelay";
static const char* CMockString_vTaskDelayUntil = "vTaskDelayUntil";
static const char* CMockString_xTaskCreate = "xTaskCreate";
static const char* CMockString_xTaskGetTickCount = "xTaskGetTickCount";
static const char* CMockString_xTaskGetTickCountFromISR = "xTaskGetTickCountFromISR";
static const char* CMockString_xTicksToDelay = "xTicksToDelay";
static const char* CMockString_xTimeIncrement = "xTimeIncrement";

typedef struct _CMOCK_taskENTER_CRITICAL_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_taskENTER_CRITICAL_CALL_INSTANCE;

typedef struct _CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCount_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  TickType_t ReturnVal;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_xTaskGetTickCount_CALL_INSTANCE;

typedef struct _CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  TickType_t ReturnVal;
  CEXCEPTION_T ExceptionToThrow;

} CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  TickType_t Expected_xTicksToDelay;
  CEXCEPTION_T ExceptionToThrow;
  int IgnoreArg_xTicksToDelay;

} CMOCK_vTaskDelay_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelayUntil_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  TickType_t* Expected_pxPreviousWakeTime;
  TickType_t Expected_xTimeIncrement;
  CEXCEPTION_T ExceptionToThrow;
  int Expected_pxPreviousWakeTime_Depth;
  int ReturnThruPtr_pxPreviousWakeTime_Used;
  TickType_t* ReturnThruPtr_pxPreviousWakeTime_Val;
  int ReturnThruPtr_pxPreviousWakeTime_Size;
  int IgnoreArg_pxPreviousWakeTime;
  int IgnoreArg_xTimeIncrement;

} CMOCK_vTaskDelayUntil_CALL_INSTANCE;

typedef struct _CMOCK_xTaskCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  TaskFunction_t Expected_pxTaskCode;
  const char* Expected_pcName;
  configSTACK_DEPTH_TYPE Expected_usStackDepth;
  void* Expected_pvParameters;
  UBaseType_t Expected_uxPriority;
  TaskHandle_t* Expected_pxCreatedTask;
  CEXCEPTION_T ExceptionToThrow;
  int Expected_pvParameters_Depth;
  int Expected_pxCreatedTask_Depth;
  int ReturnThruPtr_pvParameters_Used;
  void* ReturnThruPtr_pvParameters_Val;
  int ReturnThruPtr_pvParameters_Size;
  int ReturnThruPtr_pxCreatedTask_Used;
  TaskHandle_t* ReturnThruPtr_pxCreatedTask_Val;
  int ReturnThruPtr_pxCreatedTask_Size;
  int IgnoreArg_pxTaskCode;
  int IgnoreArg_pcName;
  int IgnoreArg_usStackDepth;
  int IgnoreArg_pvParameters;
  int IgnoreArg_uxPriority;
  int IgnoreArg_pxCreatedTask;

} CMOCK_xTaskCreate_CALL_INSTANCE;

static struct MocktaskInstance
{
  int taskENTER_CRITICAL_IgnoreBool;
  int taskENTER_CRITICAL_CallbackBool;
  CMOCK_taskENTER_CRITICAL_CALLBACK taskENTER_CRITICAL_CallbackFunctionPointer;
  int taskENTER_CRITICAL_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE taskENTER_CRITICAL_CallInstance;
  int taskEXIT_CRITICAL_IgnoreBool;
  int taskEXIT_CRITICAL_CallbackBool;
  CMOCK_taskEXIT_CRITICAL_CALLBACK taskEXIT_CRITICAL_CallbackFunctionPointer;
  int taskEXIT_CRITICAL_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE taskEXIT_CRITICAL_CallInstance;
  int xTaskGetTickCount_IgnoreBool;
  TickType_t xTaskGetTickCount_FinalReturn;
  int xTaskGetTickCount_CallbackBool;
  CMOCK_xTaskGetTickCount_CALLBACK xTaskGetTickCount_CallbackFunctionPointer;
  int xTaskGetTickCount_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCount_CallInstance;
  int xTaskGetTickCountFromISR_IgnoreBool;
  TickType_t xTaskGetTickCountFromISR_FinalReturn;
  int xTaskGetTickCountFromISR_CallbackBool;
  CMOCK_xTaskGetTickCountFromISR_CALLBACK xTaskGetTickCountFromISR_CallbackFunctionPointer;
  int xTaskGetTickCountFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTaskGetTickCountFromISR_CallInstance;
  int vTaskDelay_IgnoreBool;
  int vTaskDelay_CallbackBool;
  CMOCK_vTaskDelay_CALLBACK vTaskDelay_CallbackFunctionPointer;
  int vTaskDelay_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTaskDelay_CallInstance;
  int vTaskDelayUntil_IgnoreBool;
  int vTaskDelayUntil_CallbackBool;
  CMOCK_vTaskDelayUntil_CALLBACK vTaskDelayUntil_CallbackFunctionPointer;
  int vTaskDelayUntil_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTaskDelayUntil_CallInstance;
  int xTaskCreate_IgnoreBool;
  BaseType_t xTaskCreate_FinalReturn;
  int xTaskCreate_CallbackBool;
  CMOCK_xTaskCreate_CALLBACK xTaskCreate_CallbackFunctionPointer;
  int xTaskCreate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTaskCreate_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocktask_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.taskENTER_CRITICAL_CallInstance;
  if (Mock.taskENTER_CRITICAL_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_taskENTER_CRITICAL);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.taskENTER_CRITICAL_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.taskEXIT_CRITICAL_CallInstance;
  if (Mock.taskEXIT_CRITICAL_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_taskEXIT_CRITICAL);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.taskEXIT_CRITICAL_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.xTaskGetTickCount_CallInstance;
  if (Mock.xTaskGetTickCount_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.xTaskGetTickCount_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.xTaskGetTickCountFromISR_CallInstance;
  if (Mock.xTaskGetTickCountFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.vTaskDelay_CallInstance;
  if (Mock.vTaskDelay_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_vTaskDelay);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.vTaskDelay_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.vTaskDelayUntil_CallInstance;
  if (Mock.vTaskDelayUntil_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_vTaskDelayUntil);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.vTaskDelayUntil_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
  call_instance = Mock.xTaskCreate_CallInstance;
  if (Mock.xTaskCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  UNITY_SET_DETAIL(CMockString_xTaskCreate);
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == call_instance, cmock_line, CMockStringCalledLess);
  UNITY_CLR_DETAILS();
  if (Mock.xTaskCreate_CallbackFunctionPointer != NULL)
    call_instance = CMOCK_GUTS_NONE;
}

void Mocktask_Init(void)
{
  Mocktask_Destroy();
}

void Mocktask_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void taskENTER_CRITICAL(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_taskENTER_CRITICAL_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_taskENTER_CRITICAL);
  cmock_call_instance = (CMOCK_taskENTER_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.taskENTER_CRITICAL_CallInstance);
  Mock.taskENTER_CRITICAL_CallInstance = CMock_Guts_MemNext(Mock.taskENTER_CRITICAL_CallInstance);
  if (Mock.taskENTER_CRITICAL_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.taskENTER_CRITICAL_CallbackBool &&
      Mock.taskENTER_CRITICAL_CallbackFunctionPointer != NULL)
  {
    Mock.taskENTER_CRITICAL_CallbackFunctionPointer(Mock.taskENTER_CRITICAL_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.taskENTER_CRITICAL_CallbackFunctionPointer != NULL)
  {
    Mock.taskENTER_CRITICAL_CallbackFunctionPointer(Mock.taskENTER_CRITICAL_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void taskENTER_CRITICAL_CMockIgnore(void)
{
  Mock.taskENTER_CRITICAL_IgnoreBool = (int)1;
}

void taskENTER_CRITICAL_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_taskENTER_CRITICAL_CALL_INSTANCE));
  CMOCK_taskENTER_CRITICAL_CALL_INSTANCE* cmock_call_instance = (CMOCK_taskENTER_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.taskENTER_CRITICAL_CallInstance = CMock_Guts_MemChain(Mock.taskENTER_CRITICAL_CallInstance, cmock_guts_index);
  Mock.taskENTER_CRITICAL_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
}

void taskENTER_CRITICAL_AddCallback(CMOCK_taskENTER_CRITICAL_CALLBACK Callback)
{
  Mock.taskENTER_CRITICAL_IgnoreBool = (int)0;
  Mock.taskENTER_CRITICAL_CallbackBool = (int)1;
  Mock.taskENTER_CRITICAL_CallbackFunctionPointer = Callback;
}

void taskENTER_CRITICAL_Stub(CMOCK_taskENTER_CRITICAL_CALLBACK Callback)
{
  Mock.taskENTER_CRITICAL_IgnoreBool = (int)0;
  Mock.taskENTER_CRITICAL_CallbackBool = (int)0;
  Mock.taskENTER_CRITICAL_CallbackFunctionPointer = Callback;
}

void taskENTER_CRITICAL_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_taskENTER_CRITICAL_CALL_INSTANCE));
  CMOCK_taskENTER_CRITICAL_CALL_INSTANCE* cmock_call_instance = (CMOCK_taskENTER_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.taskENTER_CRITICAL_CallInstance = CMock_Guts_MemChain(Mock.taskENTER_CRITICAL_CallInstance, cmock_guts_index);
  Mock.taskENTER_CRITICAL_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void taskEXIT_CRITICAL(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_taskEXIT_CRITICAL);
  cmock_call_instance = (CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.taskEXIT_CRITICAL_CallInstance);
  Mock.taskEXIT_CRITICAL_CallInstance = CMock_Guts_MemNext(Mock.taskEXIT_CRITICAL_CallInstance);
  if (Mock.taskEXIT_CRITICAL_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.taskEXIT_CRITICAL_CallbackBool &&
      Mock.taskEXIT_CRITICAL_CallbackFunctionPointer != NULL)
  {
    Mock.taskEXIT_CRITICAL_CallbackFunctionPointer(Mock.taskEXIT_CRITICAL_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.taskEXIT_CRITICAL_CallbackFunctionPointer != NULL)
  {
    Mock.taskEXIT_CRITICAL_CallbackFunctionPointer(Mock.taskEXIT_CRITICAL_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void taskEXIT_CRITICAL_CMockIgnore(void)
{
  Mock.taskEXIT_CRITICAL_IgnoreBool = (int)1;
}

void taskEXIT_CRITICAL_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE));
  CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE* cmock_call_instance = (CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.taskEXIT_CRITICAL_CallInstance = CMock_Guts_MemChain(Mock.taskEXIT_CRITICAL_CallInstance, cmock_guts_index);
  Mock.taskEXIT_CRITICAL_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
}

void taskEXIT_CRITICAL_AddCallback(CMOCK_taskEXIT_CRITICAL_CALLBACK Callback)
{
  Mock.taskEXIT_CRITICAL_IgnoreBool = (int)0;
  Mock.taskEXIT_CRITICAL_CallbackBool = (int)1;
  Mock.taskEXIT_CRITICAL_CallbackFunctionPointer = Callback;
}

void taskEXIT_CRITICAL_Stub(CMOCK_taskEXIT_CRITICAL_CALLBACK Callback)
{
  Mock.taskEXIT_CRITICAL_IgnoreBool = (int)0;
  Mock.taskEXIT_CRITICAL_CallbackBool = (int)0;
  Mock.taskEXIT_CRITICAL_CallbackFunctionPointer = Callback;
}

void taskEXIT_CRITICAL_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE));
  CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE* cmock_call_instance = (CMOCK_taskEXIT_CRITICAL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.taskEXIT_CRITICAL_CallInstance = CMock_Guts_MemChain(Mock.taskEXIT_CRITICAL_CallInstance, cmock_guts_index);
  Mock.taskEXIT_CRITICAL_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

TickType_t xTaskGetTickCount(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCount);
  cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCount_CallInstance);
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCount_CallInstance);
  if (Mock.xTaskGetTickCount_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTaskGetTickCount_FinalReturn;
    memcpy((void*)(&Mock.xTaskGetTickCount_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTaskGetTickCount_CallbackBool &&
      Mock.xTaskGetTickCount_CallbackFunctionPointer != NULL)
  {
    TickType_t ret = Mock.xTaskGetTickCount_CallbackFunctionPointer(Mock.xTaskGetTickCount_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.xTaskGetTickCount_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTaskGetTickCount_CallbackFunctionPointer(Mock.xTaskGetTickCount_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCount_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCount_CALL_INSTANCE));
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCount_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCount_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTaskGetTickCount_IgnoreBool = (int)1;
}

void xTaskGetTickCount_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCount_CALL_INSTANCE));
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCount_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCount_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTaskGetTickCount_AddCallback(CMOCK_xTaskGetTickCount_CALLBACK Callback)
{
  Mock.xTaskGetTickCount_IgnoreBool = (int)0;
  Mock.xTaskGetTickCount_CallbackBool = (int)1;
  Mock.xTaskGetTickCount_CallbackFunctionPointer = Callback;
}

void xTaskGetTickCount_Stub(CMOCK_xTaskGetTickCount_CALLBACK Callback)
{
  Mock.xTaskGetTickCount_IgnoreBool = (int)0;
  Mock.xTaskGetTickCount_CallbackBool = (int)0;
  Mock.xTaskGetTickCount_CallbackFunctionPointer = Callback;
}

void xTaskGetTickCount_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCount_CALL_INSTANCE));
  CMOCK_xTaskGetTickCount_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCount_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCount_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCount_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCount_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

TickType_t xTaskGetTickCountFromISR(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskGetTickCountFromISR);
  cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskGetTickCountFromISR_CallInstance);
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTaskGetTickCountFromISR_CallInstance);
  if (Mock.xTaskGetTickCountFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTaskGetTickCountFromISR_FinalReturn;
    memcpy((void*)(&Mock.xTaskGetTickCountFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTaskGetTickCountFromISR_CallbackBool &&
      Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer != NULL)
  {
    TickType_t ret = Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer(Mock.xTaskGetTickCountFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer(Mock.xTaskGetTickCountFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTaskGetTickCountFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCountFromISR_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)1;
}

void xTaskGetTickCountFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCountFromISR_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTaskGetTickCountFromISR_AddCallback(CMOCK_xTaskGetTickCountFromISR_CALLBACK Callback)
{
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)0;
  Mock.xTaskGetTickCountFromISR_CallbackBool = (int)1;
  Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer = Callback;
}

void xTaskGetTickCountFromISR_Stub(CMOCK_xTaskGetTickCountFromISR_CALLBACK Callback)
{
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)0;
  Mock.xTaskGetTickCountFromISR_CallbackBool = (int)0;
  Mock.xTaskGetTickCountFromISR_CallbackFunctionPointer = Callback;
}

void xTaskGetTickCountFromISR_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE));
  CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskGetTickCountFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskGetTickCountFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTaskGetTickCountFromISR_CallInstance, cmock_guts_index);
  Mock.xTaskGetTickCountFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void vTaskDelay(const TickType_t xTicksToDelay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelay);
  cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelay_CallInstance);
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelay_CallInstance);
  if (Mock.vTaskDelay_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vTaskDelay_CallbackBool &&
      Mock.vTaskDelay_CallbackFunctionPointer != NULL)
  {
    Mock.vTaskDelay_CallbackFunctionPointer(xTicksToDelay, Mock.vTaskDelay_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xTicksToDelay)
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelay,CMockString_xTicksToDelay);
    if (&cmock_call_instance->Expected_xTicksToDelay != &xTicksToDelay) {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay), sizeof(TickType_t), cmock_line, CMockStringMismatch);
      }
  }
  }
  if (Mock.vTaskDelay_CallbackFunctionPointer != NULL)
  {
    Mock.vTaskDelay_CallbackFunctionPointer(xTicksToDelay, Mock.vTaskDelay_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToDelay);
void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t xTicksToDelay)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToDelay), (void*)(&xTicksToDelay),
         sizeof(TickType_t[sizeof(xTicksToDelay) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToDelay = 0;
}

void vTaskDelay_CMockIgnore(void)
{
  Mock.vTaskDelay_IgnoreBool = (int)1;
}

void vTaskDelay_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  Mock.vTaskDelay_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExpectAnyArgsBool = (int)1;
}

void vTaskDelay_CMockExpect(UNITY_LINE_TYPE cmock_line, const TickType_t xTicksToDelay)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  Mock.vTaskDelay_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_vTaskDelay(cmock_call_instance, xTicksToDelay);
}

void vTaskDelay_AddCallback(CMOCK_vTaskDelay_CALLBACK Callback)
{
  Mock.vTaskDelay_IgnoreBool = (int)0;
  Mock.vTaskDelay_CallbackBool = (int)1;
  Mock.vTaskDelay_CallbackFunctionPointer = Callback;
}

void vTaskDelay_Stub(CMOCK_vTaskDelay_CALLBACK Callback)
{
  Mock.vTaskDelay_IgnoreBool = (int)0;
  Mock.vTaskDelay_CallbackBool = (int)0;
  Mock.vTaskDelay_CallbackFunctionPointer = Callback;
}

void vTaskDelay_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, const TickType_t xTicksToDelay, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  Mock.vTaskDelay_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_vTaskDelay(cmock_call_instance, xTicksToDelay);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void vTaskDelay_CMockIgnoreArg_xTicksToDelay(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelay_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToDelay = 1;
}

void vTaskDelayUntil(TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTaskDelayUntil);
  cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelayUntil_CallInstance);
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelayUntil_CallInstance);
  if (Mock.vTaskDelayUntil_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vTaskDelayUntil_CallbackBool &&
      Mock.vTaskDelayUntil_CallbackFunctionPointer != NULL)
  {
    Mock.vTaskDelayUntil_CallbackFunctionPointer(pxPreviousWakeTime, xTimeIncrement, Mock.vTaskDelayUntil_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxPreviousWakeTime)
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelayUntil,CMockString_pxPreviousWakeTime);
    if (cmock_call_instance->Expected_pxPreviousWakeTime != pxPreviousWakeTime) {
    if (cmock_call_instance->Expected_pxPreviousWakeTime == NULL)
      { UNITY_TEST_ASSERT_NULL(pxPreviousWakeTime, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxPreviousWakeTime), (void*)(pxPreviousWakeTime), sizeof(TickType_t), cmock_call_instance->Expected_pxPreviousWakeTime_Depth, cmock_line, CMockStringMismatch); }
      }
  }
  if (!cmock_call_instance->IgnoreArg_xTimeIncrement)
  {
    UNITY_SET_DETAILS(CMockString_vTaskDelayUntil,CMockString_xTimeIncrement);
    if (&cmock_call_instance->Expected_xTimeIncrement != &xTimeIncrement) {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement), sizeof(TickType_t), cmock_line, CMockStringMismatch);
      }
  }
  }
  if (Mock.vTaskDelayUntil_CallbackFunctionPointer != NULL)
  {
    Mock.vTaskDelayUntil_CallbackFunctionPointer(pxPreviousWakeTime, xTimeIncrement, Mock.vTaskDelayUntil_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  if (cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxPreviousWakeTime, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxPreviousWakeTime, (void*)cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Val,
      cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTaskDelayUntil(CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance, TickType_t* const pxPreviousWakeTime, int pxPreviousWakeTime_Depth, const TickType_t xTimeIncrement);
void CMockExpectParameters_vTaskDelayUntil(CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance, TickType_t* const pxPreviousWakeTime, int pxPreviousWakeTime_Depth, const TickType_t xTimeIncrement)
{
  cmock_call_instance->Expected_pxPreviousWakeTime = pxPreviousWakeTime;
  cmock_call_instance->Expected_pxPreviousWakeTime_Depth = pxPreviousWakeTime_Depth;
  cmock_call_instance->IgnoreArg_pxPreviousWakeTime = 0;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimeIncrement), (void*)(&xTimeIncrement),
         sizeof(TickType_t[sizeof(xTimeIncrement) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimeIncrement = 0;
}

void vTaskDelayUntil_CMockIgnore(void)
{
  Mock.vTaskDelayUntil_IgnoreBool = (int)1;
}

void vTaskDelayUntil_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ExpectAnyArgsBool = (int)1;
}

void vTaskDelayUntil_CMockExpect(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_vTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, 1, xTimeIncrement);
}

void vTaskDelayUntil_AddCallback(CMOCK_vTaskDelayUntil_CALLBACK Callback)
{
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  Mock.vTaskDelayUntil_CallbackBool = (int)1;
  Mock.vTaskDelayUntil_CallbackFunctionPointer = Callback;
}

void vTaskDelayUntil_Stub(CMOCK_vTaskDelayUntil_CALLBACK Callback)
{
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  Mock.vTaskDelayUntil_CallbackBool = (int)0;
  Mock.vTaskDelayUntil_CallbackFunctionPointer = Callback;
}

void vTaskDelayUntil_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, const TickType_t xTimeIncrement, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_vTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, 1, xTimeIncrement);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void vTaskDelayUntil_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TickType_t* const pxPreviousWakeTime, int pxPreviousWakeTime_Depth, const TickType_t xTimeIncrement)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelayUntil_CALL_INSTANCE));
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelayUntil_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelayUntil_CallInstance, cmock_guts_index);
  Mock.vTaskDelayUntil_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_vTaskDelayUntil(cmock_call_instance, pxPreviousWakeTime, pxPreviousWakeTime_Depth, xTimeIncrement);
}

void vTaskDelayUntil_CMockReturnMemThruPtr_pxPreviousWakeTime(UNITY_LINE_TYPE cmock_line, TickType_t* pxPreviousWakeTime, int cmock_size)
{
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Val = pxPreviousWakeTime;
  cmock_call_instance->ReturnThruPtr_pxPreviousWakeTime_Size = cmock_size;
}

void vTaskDelayUntil_CMockIgnoreArg_pxPreviousWakeTime(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxPreviousWakeTime = 1;
}

void vTaskDelayUntil_CMockIgnoreArg_xTimeIncrement(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTaskDelayUntil_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelayUntil_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTaskDelayUntil_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimeIncrement = 1;
}

BaseType_t xTaskCreate(TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTaskCreate);
  cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTaskCreate_CallInstance);
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemNext(Mock.xTaskCreate_CallInstance);
  if (Mock.xTaskCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTaskCreate_FinalReturn;
    memcpy((void*)(&Mock.xTaskCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTaskCreate_CallbackBool &&
      Mock.xTaskCreate_CallbackFunctionPointer != NULL)
  {
    BaseType_t ret = Mock.xTaskCreate_CallbackFunctionPointer(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, Mock.xTaskCreate_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxTaskCode)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxTaskCode);
    if (&cmock_call_instance->Expected_pxTaskCode != &pxTaskCode) {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode), sizeof(TaskFunction_t), cmock_line, CMockStringMismatch);
      }
  }
  if (!cmock_call_instance->IgnoreArg_pcName)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pcName);
    if (cmock_call_instance->Expected_pcName != pcName) {
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcName, pcName, cmock_line, CMockStringMismatch);
      }
  }
  if (!cmock_call_instance->IgnoreArg_usStackDepth)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_usStackDepth);
    if (&cmock_call_instance->Expected_usStackDepth != &usStackDepth) {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_usStackDepth), (void*)(&usStackDepth), sizeof(configSTACK_DEPTH_TYPE), cmock_line, CMockStringMismatch);
      }
  }
  if (!cmock_call_instance->IgnoreArg_pvParameters)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pvParameters);
    if (cmock_call_instance->Expected_pvParameters != pvParameters) {
    if (cmock_call_instance->Expected_pvParameters == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameters, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameters, pvParameters, cmock_call_instance->Expected_pvParameters_Depth, cmock_line, CMockStringMismatch); }
      }
  }
  if (!cmock_call_instance->IgnoreArg_uxPriority)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_uxPriority);
    if (&cmock_call_instance->Expected_uxPriority != &uxPriority) {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
      }
  }
  if (!cmock_call_instance->IgnoreArg_pxCreatedTask)
  {
    UNITY_SET_DETAILS(CMockString_xTaskCreate,CMockString_pxCreatedTask);
    if (cmock_call_instance->Expected_pxCreatedTask != pxCreatedTask) {
    if (cmock_call_instance->Expected_pxCreatedTask == NULL)
      { UNITY_TEST_ASSERT_NULL(pxCreatedTask, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxCreatedTask), (void*)(pxCreatedTask), sizeof(TaskHandle_t), cmock_call_instance->Expected_pxCreatedTask_Depth, cmock_line, CMockStringMismatch); }
      }
  }
  }
  if (Mock.xTaskCreate_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTaskCreate_CallbackFunctionPointer(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask, Mock.xTaskCreate_CallbackCalls++);
  }
  if (cmock_call_instance->ExceptionToThrow != CEXCEPTION_NONE)
  {
    UNITY_CLR_DETAILS();
    Throw(cmock_call_instance->ExceptionToThrow);
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameters_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameters, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameters, (void*)cmock_call_instance->ReturnThruPtr_pvParameters_Val,
      cmock_call_instance->ReturnThruPtr_pvParameters_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxCreatedTask, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxCreatedTask, (void*)cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val,
      cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTaskCreate(CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, int pxCreatedTask_Depth);
void CMockExpectParameters_xTaskCreate(CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, int pxCreatedTask_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_pxTaskCode), (void*)(&pxTaskCode),
         sizeof(TaskFunction_t[sizeof(pxTaskCode) == sizeof(TaskFunction_t) ? 1 : -1])); /* add TaskFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxTaskCode = 0;
  cmock_call_instance->Expected_pcName = pcName;
  cmock_call_instance->IgnoreArg_pcName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_usStackDepth), (void*)(&usStackDepth),
         sizeof(configSTACK_DEPTH_TYPE[sizeof(usStackDepth) == sizeof(configSTACK_DEPTH_TYPE) ? 1 : -1])); /* add configSTACK_DEPTH_TYPE to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_usStackDepth = 0;
  cmock_call_instance->Expected_pvParameters = pvParameters;
  cmock_call_instance->Expected_pvParameters_Depth = pvParameters_Depth;
  cmock_call_instance->IgnoreArg_pvParameters = 0;
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxPriority), (void*)(&uxPriority),
         sizeof(UBaseType_t[sizeof(uxPriority) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxPriority = 0;
  cmock_call_instance->Expected_pxCreatedTask = pxCreatedTask;
  cmock_call_instance->Expected_pxCreatedTask_Depth = pxCreatedTask_Depth;
  cmock_call_instance->IgnoreArg_pxCreatedTask = 0;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 0;
}

void xTaskCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  Mock.xTaskCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTaskCreate_IgnoreBool = (int)1;
}

void xTaskCreate_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  Mock.xTaskCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (int)1;
}

void xTaskCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  Mock.xTaskCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, usStackDepth, pvParameters, 1, uxPriority, pxCreatedTask, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTaskCreate_AddCallback(CMOCK_xTaskCreate_CALLBACK Callback)
{
  Mock.xTaskCreate_IgnoreBool = (int)0;
  Mock.xTaskCreate_CallbackBool = (int)1;
  Mock.xTaskCreate_CallbackFunctionPointer = Callback;
}

void xTaskCreate_Stub(CMOCK_xTaskCreate_CALLBACK Callback)
{
  Mock.xTaskCreate_IgnoreBool = (int)0;
  Mock.xTaskCreate_CallbackBool = (int)0;
  Mock.xTaskCreate_CallbackFunctionPointer = Callback;
}

void xTaskCreate_CMockExpectAndThrow(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, CEXCEPTION_T cmock_to_throw)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  Mock.xTaskCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, usStackDepth, pvParameters, 1, uxPriority, pxCreatedTask, 1);
  cmock_call_instance->ExceptionToThrow = cmock_to_throw;
}

void xTaskCreate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TaskFunction_t pxTaskCode, const char* const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void* const pvParameters, int pvParameters_Depth, UBaseType_t uxPriority, TaskHandle_t* const pxCreatedTask, int pxCreatedTask_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTaskCreate_CALL_INSTANCE));
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTaskCreate_CallInstance = CMock_Guts_MemChain(Mock.xTaskCreate_CallInstance, cmock_guts_index);
  Mock.xTaskCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExceptionToThrow = CEXCEPTION_NONE;
  cmock_call_instance->ExpectAnyArgsBool = (int)0;
  CMockExpectParameters_xTaskCreate(cmock_call_instance, pxTaskCode, pcName, usStackDepth, pvParameters, pvParameters_Depth, uxPriority, pxCreatedTask, pxCreatedTask_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTaskCreate_CMockReturnMemThruPtr_pvParameters(UNITY_LINE_TYPE cmock_line, void* pvParameters, int cmock_size)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameters_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameters_Val = pvParameters;
  cmock_call_instance->ReturnThruPtr_pvParameters_Size = cmock_size;
}

void xTaskCreate_CMockReturnMemThruPtr_pxCreatedTask(UNITY_LINE_TYPE cmock_line, TaskHandle_t* pxCreatedTask, int cmock_size)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Val = pxCreatedTask;
  cmock_call_instance->ReturnThruPtr_pxCreatedTask_Size = cmock_size;
}

void xTaskCreate_CMockIgnoreArg_pxTaskCode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskCode = 1;
}

void xTaskCreate_CMockIgnoreArg_pcName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcName = 1;
}

void xTaskCreate_CMockIgnoreArg_usStackDepth(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_usStackDepth = 1;
}

void xTaskCreate_CMockIgnoreArg_pvParameters(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameters = 1;
}

void xTaskCreate_CMockIgnoreArg_uxPriority(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxPriority = 1;
}

void xTaskCreate_CMockIgnoreArg_pxCreatedTask(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTaskCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTaskCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTaskCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCreatedTask = 1;
}

